# PostGraphile GraphQL Schema for Waypoint Database

This document describes the GraphQL schema automatically generated by PostGraphile from the Waypoint database. The schema provides a complete GraphQL API for querying Farcaster protocol data including users, casts, reactions, links (follows), and on-chain events.

## Overview

PostGraphile automatically generates a GraphQL schema based on the PostgreSQL database structure. It follows these conventions:

- **Table names** → UpperCamelCase singular types (e.g., `casts` → `Cast`, `user_data` → `UserDatum`)
- **Column names** → camelCase fields (e.g., `created_at` → `createdAt`)
- **Collections** → Relay-style connections with cursor-based pagination
- **Timestamps** → ISO 8601 datetime strings
- **BigInt values** → Must be passed as strings in queries (e.g., `fid: "12345"` not `fid: 12345`)

## ⚠️ Important: No Foreign Key Relations

**The Waypoint database schema does not define foreign key constraints.** This means PostGraphile will NOT automatically generate relation fields between tables (e.g., `userDataByFid`, `parentCast`, `reactions`).

**What IS generated:**
- ✅ Basic table types with all columns
- ✅ Unique constraint queries (e.g., `userDatumByFidAndType`, `castByHash`)
- ✅ Collection queries with pagination (e.g., `allCasts`, `allLinks`)
- ✅ Filtering, ordering, and conditions

**What is NOT generated:**
- ❌ Relation fields between tables (e.g., `cast.userDataByFid`, `cast.reactions`)
- ❌ Nested queries across tables

**To query related data, you must:**
1. Make separate queries and join data in your application code
2. Or add foreign key constraints to enable automatic relations (see [Adding Foreign Keys](#adding-foreign-keys-for-automatic-relations))

---

## Core Types

### Message

Protocol messages with cryptographic verification. Base type for most Farcaster data.

```graphql
type Message {
  nodeId: ID!
  id: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
  timestamp: Datetime
  deletedAt: Datetime
  prunedAt: Datetime
  fid: BigInt!
  hash: String!
  hashScheme: Int!
  signature: String!
  signatureScheme: Int!
  signer: String!
  body: JSON
  raw: String  # bytea encoded
  type: Int!
}
```

---

### Cast

Social posts/messages with optional embeds, mentions, and threading support.

```graphql
type Cast {
  nodeId: ID!
  id: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
  timestamp: Datetime
  deletedAt: Datetime
  fid: BigInt  # nullable for CRDT out-of-order messages
  parentFid: BigInt
  hash: String!
  parentHash: String  # for replies/threads
  parentUrl: String
  text: String!
  embeds: JSON  # array of embed objects
  mentions: JSON  # array of mentioned FIDs
  mentionsPositions: JSON  # byte positions of mentions
  type: Int!
}
```

**Indexes optimized for:**
- Feed queries (by FID + timestamp)
- Thread traversal (by parentHash)
- Active casts (non-deleted)

---

### Reaction

Engagement data for likes, recasts, and other interaction types.

```graphql
type Reaction {
  nodeId: ID!
  id: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
  timestamp: Datetime
  deletedAt: Datetime
  fid: BigInt!
  type: Int!  # reaction type enum (1=like, 2=recast)
  hash: String!
  targetCastHash: String
  targetUrl: String
}
```

**Supports:**
- Hash-based targets (casts)
- URL-based targets (external content)

---

### Link

Social graph relationships including follows, blocks, and other connection types.

```graphql
type Link {
  nodeId: ID!
  id: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
  timestamp: Datetime
  deletedAt: Datetime
  fid: BigInt!
  targetFid: BigInt!
  type: String!  # "follow", "block", etc.
  hash: String!
}
```

**Key queries:**
- Following list (outbound links from FID)
- Followers list (inbound links to targetFid)

---

### UserDatum

Profile metadata including display names, bios, avatars, and other user attributes.

**Note:** PostGraphile singularizes `user_data` → `UserDatum` (not `UserData`)

```graphql
type UserDatum {
  nodeId: ID!
  id: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
  timestamp: Datetime
  deletedAt: Datetime
  fid: BigInt!
  type: Int!  # data type enum (1=PFP, 2=DISPLAY, 3=BIO, 5=URL, 6=USERNAME)
  value: String!
  hash: String!
}
```

**User Data Types:**
- `1` = PFP (profile picture URL)
- `2` = DISPLAY (display name)
- `3` = BIO (bio text)
- `5` = URL (website URL)
- `6` = USERNAME (username)

**Constraint:** Unique (fid, type) - one value per type per user

---

### Verification

Cryptographic proofs of signer ownership linking addresses to FIDs.

```graphql
type Verification {
  nodeId: ID!
  id: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
  timestamp: Datetime
  deletedAt: Datetime
  signerAddress: String!
  fid: BigInt!
  signature: String!
  blockHash: String!
}
```

**Constraint:** Unique (signerAddress, fid)

---

### UsernameProof

ENS or domain-based identity claims proving username ownership.

```graphql
type UsernameProof {
  nodeId: ID!
  id: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
  timestamp: Datetime
  deletedAt: Datetime
  fid: BigInt!
  username: String!
  signature: String!
  owner: String!
}
```

**Constraint:** Unique (username, fid)

---

## On-Chain Event Types

### SignerEvent

Key management operations: adding/removing signers, admin resets.

```graphql
type SignerEvent {
  nodeId: ID!
  id: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
  timestamp: Datetime
  deletedAt: Datetime
  fid: BigInt!
  key: String!
  keyType: Int!
  eventType: Int!  # add, remove, admin_reset
  metadata: String
  metadataType: Int
  blockNumber: BigInt!
  blockHash: String!
  txHash: String!
  logIndex: Int!
  chainId: Int!
}
```

---

### SignerMigratedEvent

Signer migration timestamps and blockchain metadata.

```graphql
type SignerMigratedEvent {
  nodeId: ID!
  id: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
  timestamp: Datetime
  deletedAt: Datetime
  fid: BigInt!
  migratedAt: BigInt!
  blockNumber: BigInt!
  blockHash: String!
  txHash: String!
  logIndex: Int!
  chainId: Int!
}
```

---

### IdRegisterEvent

Identity registration, transfers, and recovery address changes.

```graphql
type IdRegisterEvent {
  nodeId: ID!
  id: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
  timestamp: Datetime
  deletedAt: Datetime
  fid: BigInt!
  to: String!
  from: String
  eventType: Int!  # register, transfer, change_recovery
  recoveryAddress: String
  blockNumber: BigInt!
  blockHash: String!
  txHash: String!
  logIndex: Int!
  chainId: Int!
}
```

---

### StorageRentEvent

Storage rent payments with unit quantities and expiration tracking.

```graphql
type StorageRentEvent {
  nodeId: ID!
  id: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
  timestamp: Datetime
  deletedAt: Datetime
  fid: BigInt!
  payer: String!
  units: Int!
  expiry: BigInt!
  blockNumber: BigInt!
  blockHash: String!
  txHash: String!
  logIndex: Int!
  chainId: Int!
}
```

---

### TierPurchase

Farcaster Pro tier subscription purchases and durations.

```graphql
type TierPurchase {
  nodeId: ID!
  id: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
  timestamp: Datetime
  deletedAt: Datetime
  fid: BigInt!
  tierType: Int!  # 0=None, 1=Pro
  forDays: Int!
  payer: String!
  blockNumber: BigInt!
  blockHash: String!
  txHash: String!
  logIndex: Int!
  txIndex: Int!
  blockTimestamp: BigInt!
  chainId: Int!
}
```

---

### LendStorage

Storage unit lending between accounts.

```graphql
type LendStorage {
  nodeId: ID!
  id: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
  timestamp: Datetime
  deletedAt: Datetime
  fid: BigInt!  # lender
  toFid: BigInt!  # recipient
  numUnits: Int!
  unitType: Int!  # legacy, 2024, 2025
  hash: String!
}
```

---

## Root Query Type

### Single Record Queries

Fetch individual records by primary key or unique constraint:

```graphql
type Query {
  # By primary key (UUID)
  message(id: UUID!): Message
  cast(id: UUID!): Cast
  reaction(id: UUID!): Reaction
  link(id: UUID!): Link
  userDatum(id: UUID!): UserDatum

  # By unique constraints
  castByHash(hash: String!): Cast
  userDatumByFidAndType(fid: BigInt!, type: Int!): UserDatum
  verificationBySignerAddressAndFid(signerAddress: String!, fid: BigInt!): Verification
  usernameProofByUsernameAndFid(username: String!, fid: BigInt!): UsernameProof
  linkByHash(hash: String!): Link
  lendStorageByHash(hash: String!): LendStorage
  idRegisterEventByTxHashAndLogIndex(txHash: String!, logIndex: Int!): IdRegisterEvent
}
```

### Collection Queries (Connections)

All collections return Relay-style connections with pagination:

```graphql
type Query {
  allCasts(
    first: Int
    last: Int
    offset: Int
    before: Cursor
    after: Cursor
    orderBy: [CastsOrderBy!] = [PRIMARY_KEY_ASC]
    condition: CastCondition
  ): CastsConnection

  allReactions(
    first: Int
    last: Int
    offset: Int
    before: Cursor
    after: Cursor
    orderBy: [ReactionsOrderBy!] = [PRIMARY_KEY_ASC]
    condition: ReactionCondition
  ): ReactionsConnection

  allLinks(
    first: Int
    last: Int
    offset: Int
    before: Cursor
    after: Cursor
    orderBy: [LinksOrderBy!] = [PRIMARY_KEY_ASC]
    condition: LinkCondition
  ): LinksConnection

  allUserData(
    first: Int
    last: Int
    offset: Int
    before: Cursor
    after: Cursor
    orderBy: [UserDataOrderBy!] = [PRIMARY_KEY_ASC]
    condition: UserDatumCondition
  ): UserDataConnection

  # ... similar for all other tables
}
```

---

## Connection Pattern

All collection queries return connections following the Relay specification:

```graphql
type CastsConnection {
  pageInfo: PageInfo!
  edges: [CastEdge!]!
  nodes: [Cast!]!
  totalCount: Int!
}

type CastEdge {
  cursor: Cursor!
  node: Cast!
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: Cursor
  endCursor: Cursor
}
```

---

## Ordering

Results can be ordered by any field in ascending or descending order:

```graphql
enum CastsOrderBy {
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  ID_ASC
  ID_DESC
  FID_ASC
  FID_DESC
  HASH_ASC
  HASH_DESC
  TIMESTAMP_ASC
  TIMESTAMP_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  DELETED_AT_ASC
  DELETED_AT_DESC
}
```

---

## Filtering with Conditions

Filter by exact field values using the `condition` parameter:

```graphql
input CastCondition {
  id: UUID
  fid: BigInt      # Must be a string: "12345"
  hash: String
  parentHash: String
  parentFid: BigInt
  deletedAt: Datetime  # Use null to get non-deleted casts
  type: Int
  # ... any other field
}
```

**Important:** BigInt values must be strings: `fid: "12345"` not `fid: 12345`

---

## Example Queries

### Example 1: Get Most Recent 5 Casts for a User

This query fetches the latest 5 casts from a specific user (FID 12345), ordered by timestamp descending.

**Note:** We cannot include user profile data in the same query because there are no foreign key relations. You must fetch it separately.

```graphql
query GetUserRecentCasts {
  allCasts(
    first: 5
    orderBy: [TIMESTAMP_DESC]
    condition: {
      fid: "12345"      # BigInt as string!
      deletedAt: null   # Only non-deleted casts
    }
  ) {
    pageInfo {
      hasNextPage
      endCursor
    }
    edges {
      cursor
      node {
        id
        hash
        text
        timestamp
        createdAt
        embeds
        mentions
        parentHash
        parentFid
        type
      }
    }
    totalCount
  }
}
```

**Then, separately fetch user profile:**

```graphql
query GetUserProfile {
  allUserData(
    condition: {
      fid: "12345"
      deletedAt: null
    }
  ) {
    nodes {
      type
      value
    }
  }
}
```

**In your application code, combine the results:**

```javascript
// Fetch both queries
const [castsResult, profileResult] = await Promise.all([
  fetchCasts(fid),
  fetchUserProfile(fid)
]);

// Parse profile data
const profile = {};
profileResult.allUserData.nodes.forEach(datum => {
  switch(datum.type) {
    case 1: profile.pfp = datum.value; break;
    case 2: profile.displayName = datum.value; break;
    case 3: profile.bio = datum.value; break;
    case 5: profile.url = datum.value; break;
    case 6: profile.username = datum.value; break;
  }
});

// Combine with casts
const castsWithProfile = castsResult.allCasts.edges.map(edge => ({
  ...edge.node,
  author: profile
}));
```

---

### Example 2: Get Most Recent 5 Users a User Has Followed

This query fetches the 5 most recent follow relationships created by a user (FID 12345):

```graphql
query GetRecentFollows {
  allLinks(
    first: 5
    orderBy: [TIMESTAMP_DESC]
    condition: {
      fid: "12345"     # BigInt as string!
      type: "follow"
      deletedAt: null  # Only active follows
    }
  ) {
    pageInfo {
      hasNextPage
      endCursor
    }
    edges {
      cursor
      node {
        id
        targetFid
        timestamp
        createdAt
        hash
      }
    }
    totalCount
  }
}
```

**Then fetch profile data for each followed user:**

```graphql
query GetFollowedUsersProfiles {
  # For each targetFid from above, fetch their profile
  user1: allUserData(condition: { fid: "67890", deletedAt: null }) {
    nodes {
      type
      value
    }
  }
  user2: allUserData(condition: { fid: "54321", deletedAt: null }) {
    nodes {
      type
      value
    }
  }
  # ... etc
}
```

**Or use a batch query approach:**

```graphql
query GetMultipleUserProfiles {
  allUserData(
    condition: {
      deletedAt: null
    }
    # Note: Cannot filter by multiple FIDs directly with condition
    # You'll need to filter in application code or use separate queries
  ) {
    nodes {
      fid
      type
      value
    }
  }
}
```

**Better approach - fetch all user data for relevant FIDs in app code:**

```javascript
// Step 1: Get follow links
const followsResult = await fetchFollows("12345");
const followedFids = followsResult.allLinks.edges.map(e => e.node.targetFid);

// Step 2: Fetch user data for all followed FIDs
const userDataQueries = followedFids.map(fid => `
  user${fid}: allUserData(condition: { fid: "${fid}", deletedAt: null }) {
    nodes { type value }
  }
`).join('\n');

const profilesResult = await graphql(`query { ${userDataQueries} }`);

// Step 3: Parse and combine
const profiles = {};
Object.entries(profilesResult).forEach(([key, data]) => {
  const fid = key.replace('user', '');
  profiles[fid] = parseUserData(data.nodes);
});
```

---

### Example 3: Get Reaction Count for a Cast

Count likes on a specific cast:

```graphql
query GetCastReactions($castHash: String!) {
  allReactions(
    condition: {
      targetCastHash: $castHash
      type: 1          # 1 = like, 2 = recast
      deletedAt: null
    }
  ) {
    totalCount
  }
}
```

**Variables:**
```json
{
  "castHash": "0xabc123..."
}
```

---

### Example 4: Get Thread (Parent and Replies)

Get a cast and all its replies:

**Step 1: Get the main cast:**
```graphql
query GetCast($hash: String!) {
  castByHash(hash: $hash) {
    id
    hash
    fid
    text
    timestamp
    parentHash
    embeds
    mentions
  }
}
```

**Step 2: Get replies to this cast:**
```graphql
query GetReplies($parentHash: String!) {
  allCasts(
    condition: {
      parentHash: $parentHash
      deletedAt: null
    }
    orderBy: [TIMESTAMP_ASC]
  ) {
    nodes {
      id
      hash
      fid
      text
      timestamp
      embeds
      mentions
    }
  }
}
```

**Step 3: If the cast has a parent, fetch it:**
```graphql
query GetParentCast($parentHash: String!) {
  castByHash(hash: $parentHash) {
    id
    hash
    fid
    text
    timestamp
  }
}
```

---

### Example 5: Get User Profile with Stats

Get comprehensive user information:

```graphql
query GetUserProfile($fid: BigInt!) {
  # Profile data
  profile: allUserData(
    condition: {
      fid: $fid
      deletedAt: null
    }
  ) {
    nodes {
      type
      value
    }
  }

  # Cast count
  casts: allCasts(
    condition: {
      fid: $fid
      deletedAt: null
    }
  ) {
    totalCount
  }

  # Following count
  following: allLinks(
    condition: {
      fid: $fid
      type: "follow"
      deletedAt: null
    }
  ) {
    totalCount
  }

  # Followers count
  followers: allLinks(
    condition: {
      targetFid: $fid
      type: "follow"
      deletedAt: null
    }
  ) {
    totalCount
  }

  # Recent casts
  recentCasts: allCasts(
    first: 10
    orderBy: [TIMESTAMP_DESC]
    condition: {
      fid: $fid
      deletedAt: null
    }
  ) {
    edges {
      node {
        hash
        text
        timestamp
      }
    }
  }
}
```

**Variables:**
```json
{
  "fid": "12345"
}
```

---

### Example 6: Search for Casts Containing Text

Since there's no full-text search built-in, you'll need to fetch casts and filter client-side, or use PostgreSQL functions:

```graphql
query GetRecentCasts {
  allCasts(
    first: 100
    orderBy: [TIMESTAMP_DESC]
    condition: {
      deletedAt: null
    }
  ) {
    nodes {
      hash
      text
      timestamp
      fid
    }
  }
}
```

Then filter in application code:
```javascript
const results = castsResult.allCasts.nodes.filter(cast =>
  cast.text.toLowerCase().includes(searchTerm.toLowerCase())
);
```

---

### Example 7: Get User's Feed (Posts from Followed Users)

**Step 1: Get list of followed users:**

```graphql
query GetFollowing($myFid: BigInt!) {
  allLinks(
    condition: {
      fid: $myFid
      type: "follow"
      deletedAt: null
    }
  ) {
    nodes {
      targetFid
    }
  }
}
```

**Step 2: In application code, fetch casts from those users:**

```javascript
const followedFids = followingResult.allLinks.nodes.map(n => n.targetFid);

// Build a dynamic query with OR conditions (this is a workaround)
// Better: Make separate queries or use a custom PostgreSQL function
const feedQuery = followedFids.slice(0, 10).map((fid, i) => `
  feed${i}: allCasts(
    first: 5
    orderBy: [TIMESTAMP_DESC]
    condition: { fid: "${fid}", deletedAt: null }
  ) {
    nodes {
      hash
      fid
      text
      timestamp
    }
  }
`).join('\n');

const feedResult = await graphql(`query { ${feedQuery} }`);

// Combine and sort all casts by timestamp
const allCasts = Object.values(feedResult)
  .flatMap(result => result.nodes)
  .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
```

**Note:** This approach is limited. For production, consider:
1. Creating a PostgreSQL view for feeds
2. Adding a custom GraphQL resolver
3. Using a separate feed service

---

## Performance Considerations

### Indexes

The Waypoint schema includes optimized indexes for common query patterns:

- **Feed queries:** `(fid, timestamp)` composite indexes
- **Thread traversal:** `(parent_hash)` for replies
- **Social graph:** `(target_fid)` for follower lookups
- **Active data:** Conditional indexes filtering `deleted_at IS NULL`
- **On-chain events:** `(fid)`, `(block_number)`, `(timestamp)` indexes

### Query Optimization Tips

1. **Always filter on `deletedAt: null`** to use conditional indexes
2. **Use `first`/`last` limits** instead of fetching all results
3. **Leverage cursor pagination** for large datasets (`after`, `before`)
4. **Request only needed fields** to reduce payload size
5. **Be aware of N+1 queries** when fetching related data without foreign keys
6. **Use `totalCount` sparingly** - it can be expensive on large tables
7. **Batch multiple single-item queries** using GraphQL aliases when possible

### Handling Missing Relations

Without foreign keys, you'll need to:

1. **Make multiple queries** - Fetch related data separately and join in code
2. **Use aliases** - Batch multiple queries into one GraphQL request
3. **Cache aggressively** - Store frequently accessed data (profiles, etc.)
4. **Consider denormalization** - Add computed fields or views in PostgreSQL
5. **Add foreign keys** - See next section for how to enable automatic relations

---

## Adding Foreign Keys for Automatic Relations

If you want PostGraphile to automatically generate relation fields, you need to add foreign key constraints to the database.

**⚠️ Warning:** Modifying the schema created by Waypoint migrations may cause issues with future Waypoint updates. Proceed with caution and test thoroughly.

### Example Migration to Add Foreign Keys

Create a new migration file `005_add_foreign_keys.sql`:

```sql
-- Add foreign key from casts to user_data
-- Note: This will fail if there are orphaned records
ALTER TABLE casts
  ADD CONSTRAINT casts_fid_fkey
  FOREIGN KEY (fid)
  REFERENCES user_data(fid)
  ON DELETE CASCADE;

-- Add foreign key from reactions to casts
ALTER TABLE reactions
  ADD CONSTRAINT reactions_target_cast_hash_fkey
  FOREIGN KEY (target_cast_hash)
  REFERENCES casts(hash)
  ON DELETE CASCADE;

-- Add foreign key from reactions to user_data
ALTER TABLE reactions
  ADD CONSTRAINT reactions_fid_fkey
  FOREIGN KEY (fid)
  REFERENCES user_data(fid)
  ON DELETE CASCADE;

-- Add foreign key from links to user_data (source)
ALTER TABLE links
  ADD CONSTRAINT links_fid_fkey
  FOREIGN KEY (fid)
  REFERENCES user_data(fid)
  ON DELETE CASCADE;

-- Add foreign key from links to user_data (target)
ALTER TABLE links
  ADD CONSTRAINT links_target_fid_fkey
  FOREIGN KEY (target_fid)
  REFERENCES user_data(fid)
  ON DELETE CASCADE;

-- Add self-referential foreign key for cast threads
ALTER TABLE casts
  ADD CONSTRAINT casts_parent_hash_fkey
  FOREIGN KEY (parent_hash)
  REFERENCES casts(hash)
  ON DELETE SET NULL;
```

**After adding foreign keys:**

PostGraphile will automatically generate:
- `cast.userDataByFid` - Get author profile
- `cast.reactions` - Get reactions for this cast
- `cast.parentCast` - Get parent cast for replies
- `cast.replies` - Get all replies to this cast
- `userData.casts` - Get all casts by this user
- `userData.reactions` - Get all reactions by this user
- `userData.links` - Get all links (follows) by this user
- `userData.linksAsTarget` - Get all links targeting this user (followers)

### Considerations Before Adding Foreign Keys

1. **Data integrity:** Ensure no orphaned records exist (e.g., casts with FIDs that don't exist in user_data)
2. **Performance:** Foreign keys add overhead to inserts/updates/deletes
3. **Waypoint compatibility:** Future Waypoint updates may conflict with custom constraints
4. **Cascade behavior:** Decide on DELETE/UPDATE cascade rules carefully
5. **Indexes:** Add indexes to foreign key columns for better join performance (already exist in Waypoint schema)

---

## Security Considerations

### Rate Limiting

PostGraphile doesn't include built-in rate limiting. Implement at the application layer using:
- GraphQL depth limiting (`--graphql-depth-limit`)
- Query complexity analysis
- Per-client rate limiting middleware
- Reverse proxy rate limiting (nginx, Cloudflare)

### Query Complexity

Without proper limits, expensive queries can overwhelm the database:

```graphql
# Potentially expensive query
query ExpensiveQuery {
  allCasts(first: 1000) {  # Large page size
    nodes {
      hash
      # Fetching large JSON fields
      embeds
      mentions
    }
  }
}
```

**Mitigations:**
- Set `--default-page-size` flag
- Enable `--max-rows` limit
- Monitor slow query logs
- Use PostgreSQL statement timeout

### Row-Level Security (RLS)

PostGraphile respects PostgreSQL RLS policies. Enable RLS for access control:

```sql
ALTER TABLE casts ENABLE ROW LEVEL SECURITY;

-- Example: Only show non-deleted casts
CREATE POLICY casts_public_read ON casts
  FOR SELECT
  USING (deleted_at IS NULL);

-- Example: Users can only delete their own casts
CREATE POLICY casts_user_delete ON casts
  FOR DELETE
  USING (fid = current_setting('app.current_fid')::bigint);
```

---

## GraphiQL Interface

PostGraphile provides GraphiQL (interactive GraphQL IDE) at the API endpoint (`http://r2d2:5000/graphiql`).

**Features:**
- **Schema explorer** - Browse all types, fields, and documentation
- **Autocomplete** - IntelliSense for query writing
- **Query history** - Save and reuse queries
- **Variable editor** - Test parameterized queries
- **Real-time validation** - Syntax and schema validation

**Tip:** Use the "Docs" button (top right) to explore the full schema.

---

## Deployment Configuration

### Basic PostGraphile Setup (CLI)

```bash
postgraphile \
  --connection postgres://user:pass@localhost/waypoint \
  --schema public \
  --watch \
  --enhance-graphiql \
  --dynamic-json \
  --no-setof-functions-contain-nulls \
  --no-ignore-rbac \
  --show-error-stack=json \
  --extended-errors hint,detail,errcode \
  --export-schema-graphql schema.graphql \
  --graphiql "/" \
  --port 5000
```

### Docker Compose Configuration

```yaml
graphql:
  image: graphile/postgraphile
  pull_policy: always
  restart: on-failure
  init: true
  ports:
    - "5000:5000"
  command: >
    --connection postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB:-waypoint}
    --schema public
    --watch
    --enhance-graphiql
    --dynamic-json
  networks:
    - snapchain
  depends_on:
    postgres:
      condition: service_healthy
```

### Useful PostGraphile Options

- `--watch` - Auto-reload schema on database changes
- `--enhance-graphiql` - Better GraphiQL interface
- `--dynamic-json` - JSON fields remain as JSON (not stringified)
- `--simple-collections only` - Use simpler list types instead of connections
- `--disable-query-log` - Disable query logging in production
- `--enable-query-batching` - Allow batched queries
- `--default-page-size 100` - Default pagination limit
- `--max-rows 1000` - Maximum rows returnable

---

## Troubleshooting

### Common Issues

**"Cannot query field X on type Y"**
- The field doesn't exist in the schema
- Check for typos (e.g., `UserDatum` not `UserData`)
- Relations require foreign keys (not present in Waypoint schema)

**"Expected value of type BigInt, found number"**
- BigInt values must be strings: `fid: "12345"` not `fid: 12345`

**"Cannot return null for non-nullable field"**
- The query returned null for a required field
- Check your data and ensure records exist

**Empty results when data exists**
- Check `deletedAt` filters - only query non-deleted records
- Verify FID values are correct (as strings)
- Check indexes are being used (EXPLAIN in PostgreSQL)

### Performance Issues

**Slow queries:**
1. Check PostgreSQL slow query log
2. Use `EXPLAIN ANALYZE` on generated SQL
3. Ensure indexes exist on filtered columns
4. Reduce page sizes and field selections

**High memory usage:**
1. Limit `first`/`last` parameters
2. Disable `totalCount` if not needed (expensive)
3. Enable query depth/complexity limits
4. Monitor connection pool settings

---

## References

- **PostGraphile Documentation:** https://www.graphile.org/postgraphile/
- **Waypoint Repository:** https://github.com/officialunofficial/waypoint
- **Farcaster Protocol:** https://docs.farcaster.xyz/
- **GraphQL Relay Spec:** https://relay.dev/graphql/connections.htm
- **PostgreSQL Foreign Keys:** https://www.postgresql.org/docs/current/ddl-constraints.html

---

## Changelog

- **2025-10-27:**
  - Initial schema documentation based on Waypoint migrations 001-004
  - Corrected: No automatic relations (no foreign keys in Waypoint schema)
  - Added: Working example queries without relations
  - Added: Guidance on handling missing relations and adding foreign keys
  - Fixed: BigInt values must be strings in GraphQL queries
  - Fixed: UserDatum singularization (not UserData)
